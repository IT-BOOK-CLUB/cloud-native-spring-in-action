# 클라우드 네이티브 프로젝트 부트스트래핑

- 하나의 코드, 하나의 어플리케이션
	- git과 같은 형상관리 시스템을 통해 단일한 코드 베이스로 관리해야함. 각 코드베이스는 빌드를 생성. 
	- 코드베이스 -패키징->빌드-배포->환경(프로덕션, 스테이징, QA, 개발 등)
	- 환경에 종속적인 모든 설정 등은 코드베이스 외부에 있어야 함. 
	- 코드가 2개 이상의 어플리케이션에서 필요하다면 해당 코드는 독립적인 서비스나 의존성 라이브러리로 분리해야함. 
- 의존성 관리
	- gradle or maven을 사용: manifest 파일에 의존성을 선언하고 중앙 저장소에서 다운로드할 수 있는 기능 제공.
	- 명시적 선언을 해야 어떤 라이브러리를 제공할 것이라는 암묵적인 예상하에서 실제로는 제공하지 않는 불상사를 방지
	- gradlew와 같은 wrapper script를 사용하면 프로젝트 팀원들이 모두 동일한 버전의 의존성 관리도구를 사용할 수 있다. 
- 예제의 의존성
	- spring-boot-starter-web: 스프링 MVC로 웹 개발할 때 필요한 라이브러리 + 임베디드 톰캣
	- spring-boot-starter-test: spring test + junit + mockito 등
	- 스프링 스타터 의존성 라이브러리는 import한 특정 버전이 서로 호환되는 지 확인하는 과정을 생략할 수 있게 해준다. 

# 임베디드 서버로 작업

- 스프링 부트로 클라우드 네이티브 개발을 하면 몇 가지 공통된 측면을 공유
	- 런타임 외에는 외부 의존성 X
	- 표준적이고 실행 가능한 아티팩트로 패키징
- 전통적인 방식(WAR + 톰캣)은 외부에 대한 의존성을 높여서 유지보수 비용이 상승, 환경 설정이 힘들었음. 웹서버에 변경이 있으면 해당 웹서버에 있는 여러 어플리케이션이 영향을 받게 된다. 
- 클라우드 네이티브 환경에서는 어플리케이션이 독립적이어야 하고 실행 환경이 제공하는 서버에 의존하지 않는다. 
	- 스프링 부트는 서버 기능을 내장하기 때문에 외부 의존성을 제거: 임베디드 톰캣
	- fat jar로 패키징: 어플리케이션, 의존성 라이브러리, 임베디드 서버를 모두 포함. 
```
// fat jar 만들기
./gradlew bootJar
// jar 파일 실행
java -jar [JAR 파일 이름]
```

## 요청당 스레드 모델
- 톰캣은 `thread-per-request`: 각 요청에 대해서 스레드를 할당하고 해당 스레드를 한 요청이 점유하는 방식.
- 스레드가 전부 사용되는 중이면 요청은 큐에 보관되고 스레드가 풀릴 때까지 기다린다. 
- 요청이 많아지면 필요 스레드가 많아지고 리소스 사용량이 높아진다. 
	- 전통적: 특정 인스턴스에 더 많은 리소스 추가. i.e. scale up
	- 클라우드 네이티브: 더 많은 어플리케이션 배포. i.e. scale out

### 내장 톰캣 설정
- server.port: port 설정
- server.tomcat.connection-timeout: TCP 수락에서부터 HTTP 요청을 받기 까지 톰캣이 기다리는 시간. DoS attack 방지용. 기본값 20초.
- sever.tomcat.threads: 스레드 수 설정. 최소값(min-spare), 최대값(max) 설정 가능

# Restful application 구축

- 서비스 통신에 필수적인 요소는 API. 
- 이 책에서는 API 우선 패턴을 권장. 
- API는 app간의 공개적인 계약이기 때문에 그것을 우선시 해야한다는 것. 

- 이 후로는 예제


# 배포 파이프라인

- 배포 파이프라인은 가능한 자동화 되어야 한다.
- 배포 파이프라인은 프로덕션에 배포되는 유일한 방법이어야 함.

- 배포 파이프라인의 단계
1. commit stage: 개발자가 새로운 코드를 기본 브랜치에 커밋하면 빌드, test, 정적 분석, 패키징이 진행되고 실행 가능한 아티팩트(릴리스 후보)가 저장소에 저장된다. 
2. acceptance stage: 릴리스 후보가 저장되면 이 단계가 시작된다. 프로덕션과 유사한 환경에 어플리케이션을 배포하고 릴리스 가능성에 대한 신뢰를 높이기 위한 테스트를 추가로 실행. 기능적 수용 테스트(성능테스트, 보안 테스트, 준수 테스트)와 비기능적 수용테스트를 진행. 이 단계가 끝나면 릴리스 후보는 언제든 프로덕션 환경에 배포할 수 있는 준비가 끝난 것.
3. production stage: 관행에 따라서 수동 or 자동으로 시작. 프로덕션 환경에 배포된 이후에는 최종적으로 자동화된 테스트 실행.

## 커밋 단계

- 지속적 통합(CI)는 지속적 전달의 핵심. 
- CI가 성공적으로 정착되면 개발자는 하루에도 여러 번 작은 분량의 작업을 main 브랜치에 커밋 가능. 
- 이 단계가 신속히 진행되어야 개발자가 다른 작업을 수행할 수 있게 된다. 
- 커밋 단계는 보통: 소스코드 체크아웃 -> 정적 분석 -> 빌드 -> 테스트(단위, 통합)
	- 정적 분석: 코드 컨벤션을 만족하는지 linter로 확인 + grype같은 취약성 스캐너로 코드 취약성 확인
- github action을 이용하면 커밋 단계를 쉽게 만들 수 있다


